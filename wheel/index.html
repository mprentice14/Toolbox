<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dev-Ops Wheel of Fate</title>
    <!-- Favicon -->
    <link rel="icon" href="logo.ico" type="image/x-icon">
    <link rel="shortcut icon" href="logo.ico" type="image/x-icon">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background: #0a0a0f;
            color: #e0e0ff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }
        
        body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(32, 68, 153, 0.15), rgba(10, 10, 15, 0.3));
            pointer-events: none;
            z-index: -1;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .content-row {
            display: flex;
            flex-wrap: nowrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }
        
        .wheel-section {
            flex: 0 0 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .wheel-section::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: linear-gradient(45deg, #0ff 0%, #f0f 50%, #0ff 100%);
            z-index: -1;
            filter: blur(15px);
            opacity: 0.5;
            border-radius: 20px;
            animation: neonPulse 3s infinite alternate;
        }
        
        @keyframes neonPulse {
            0% { opacity: 0.3; }
            100% { opacity: 0.7; }
        }
        
        .history-section {
            flex: 0 0 300px;
            background: rgba(25, 25, 35, 0.8);
            border: 1px solid #0ff;
            box-shadow: 0 0 15px #0ff5, 0 0 30px #0ff3;
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 400px;
            align-self: flex-start;
            margin-top: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .history-section::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #0ff, #f0f);
            filter: blur(1px);
        }
        
        .history-title {
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 15px #0ff8;
            margin-top: 0;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }
        
        .history-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        
        .history-item {
            background: rgba(40, 40, 60, 0.5);
            margin-bottom: 10px;
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 2px solid #0ff;
            display: flex;
            align-items: center;
            animation: slideIn 0.3s ease-out forwards;
            transform: translateX(50px);
            opacity: 0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        
        @keyframes slideIn {
            to { transform: translateX(0); opacity: 1; }
        }
        
        .history-item .timestamp {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-left: auto;
            font-family: 'Share Tech Mono', monospace;
            color: #f0f;
        }
        
        .clear-button {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(45deg, #222 0%, #333 100%);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            box-shadow: 0 0 10px #0ff5;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .clear-button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            transform: rotate(45deg);
            transition: all 0.5s ease;
        }
        
        .clear-button:hover {
            color: #fff;
            box-shadow: 0 0 20px #0ff;
        }
        
        .clear-button:hover::after {
            left: 100%;
        }
        
        .clear-button:active {
            transform: translateY(1px);
            box-shadow: 0 0 5px #0ff;
        }
        
        @media (max-width: 800px) {
            .content-row {
                flex-direction: column;
                align-items: center;
            }
            
            .history-section {
                width: 90%;
                margin-top: 20px;
                height: 300px;
                align-self: center;
            }
        }
        
        .title {
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            font-size: 2.8rem;
            margin-bottom: 30px;
            color: #fff;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5;
            position: relative;
            animation: glitch 5s infinite;
        }
        
        @keyframes glitch {
            0% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; }
            2% { text-shadow: 2px 0 10px #0ff, -2px 0 10px #f0f; transform: translateX(-2px); }
            3% { text-shadow: -2px 0 10px #0ff, 2px 0 10px #f0f; transform: translateX(2px); }
            4% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; transform: translateX(0); }
            42% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; }
            43% { text-shadow: 2px 0 10px #0ff, -2px 0 10px #f0f; transform: translateX(3px); }
            44% { text-shadow: -2px 0 10px #0ff, 2px 0 10px #f0f; transform: translateX(-3px); }
            45% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; transform: translateX(0); }
            100% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; }
        }
        
        #wheelContainer {
            width: 400px;
            height: 400px;
            margin: 30px auto;
            position: relative;
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            transform-style: preserve-3d;
            overflow: hidden;
            border: 3px solid #333;
        }
        
        #spinButton {
            display: block;
            margin: 30px auto;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(45deg, #222 0%, #333 100%);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }
        
        #spinButton::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s ease;
        }
        
        #spinButton:hover {
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        #spinButton:hover::after {
            left: 100%;
        }
        
        #spinButton:active {
            transform: translateY(1px);
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.4);
        }
        
        /* Add disabled button style */
        #spinButton:disabled {
            background: linear-gradient(45deg, #222 0%, #333 100%);
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7;
        }
        
        #spinButton:disabled::after {
            display: none;
        }
        
        #result {
            text-align: center;
            font-size: 2rem;
            margin-top: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #0ff;
            min-height: 60px;
            opacity: 0;
            transition: opacity 0.5s ease;
            font-family: 'Orbitron', sans-serif;
        }
        
        #result.show {
            animation: popIn 0.5s forwards, neonFlicker 2s 0.5s infinite;
            opacity: 1;
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes neonFlicker {
            0% { text-shadow: 0 0 10px #0ff; }
            5% { text-shadow: 0 0 15px #0ff; }
            10% { text-shadow: 0 0 5px #0ff; }
            15% { text-shadow: 0 0 10px #0ff; }
            80% { text-shadow: 0 0 10px #0ff; }
            85% { text-shadow: 0 0 15px #0ff; }
            95% { text-shadow: 0 0 5px #0ff; }
            100% { text-shadow: 0 0 10px #0ff; }
        }
        
        #fireworksCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #codeRainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -10;
            opacity: 0.5;
        }
        
        .wheel-pointer {
            position: absolute;
            width: 30px;
            height: 50px;
            top: -20px;
            left: calc(50% - 15px);
            background-color: #f0f;
            clip-path: polygon(50% 0, 0% 100%, 100% 100%);
            z-index: 10;
            filter: drop-shadow(0 0 10px #f0f);
        }

        /* Version number styling */
        .version {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.8rem;
            color: #0ff;
            opacity: 0.7;
            text-shadow: 0 0 5px #0ff;
            z-index: 100;
            pointer-events: none;
        }
        
        .version:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Hidden canvas for drawing the wheel texture -->
    <canvas id="wheelCanvas" width="400" height="400" style="display: none;"></canvas>
    
    <!-- Matrix-style code rain canvas -->
    <canvas id="codeRainCanvas"></canvas>
    
    <div class="container">
        <h1 class="title">DEV-OPS WHEEL OF FATE</h1>
        
        <div class="content-row">
            <div class="wheel-section">
                <!-- Wheel section -->
                <div id="wheelContainer">
                    <!-- Canvas for fireworks/effects on top of the wheel -->
                    <canvas id="fireworksCanvas" width="400" height="400"></canvas>
                    <div class="wheel-pointer"></div>
                </div>
                
                <!-- Button to start spinning -->
                <button id="spinButton">INITIALIZE SELECTION</button>
                
                <!-- Display for the selected name -->
                <div id="result"></div>
            </div>
            
            <!-- History tracking section -->
            <div class="history-section">
                <h2 class="history-title">SELECTION LOG</h2>
                <ul id="historyList" class="history-list"></ul>
                <button id="clearHistory" class="clear-button">PURGE LOG</button>
            </div>
        </div>
    </div>
    
    <!-- Container for full-screen celebration effects -->
    <div id="celebrationContainer" class="celebration"></div>

    <!-- Version number -->
    <div class="version">v3.1.1</div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Get the canvas and context
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        // List of teammates - reversed to align with pointer at bottom
        const names = ['Ronnie', 'Jake', 'Kuldeep', 'Somesh', 'Matt', 'Jeff', 'Mona'];
        // Add a set to track selected names
        const selectedNames = new Set();
        const numSegments = names.length;
        const anglePerSegment = 2 * Math.PI / numSegments;
        const radius = 180;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Function to draw the wheel on the canvas
        function drawWheel() {
            ctx.translate(centerX, centerY);
            
            // Cyberpunk colors with gradients
            const colorPairs = [
                {start: '#00FFFF', end: '#0088FF'},
                {start: '#FF00FF', end: '#CC00FF'},
                {start: '#00FF99', end: '#00CCFF'},
                {start: '#FF0099', end: '#CC00FF'},
                {start: '#9900FF', end: '#6600FF'},
                {start: '#00CCFF', end: '#0066FF'},
                {start: '#FF00CC', end: '#CC0099'}
            ];
            
            // Draw each segment with gradient
            for (let i = 0; i < numSegments; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius, i * anglePerSegment, (i + 1) * anglePerSegment);
                ctx.closePath();
                
                // Create gradient for this segment
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                const colorPair = colorPairs[i % colorPairs.length];
                gradient.addColorStop(0, '#111');
                gradient.addColorStop(0.7, '#222');
                gradient.addColorStop(0.9, colorPair.start);
                gradient.addColorStop(1, colorPair.end);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Add a glowing effect at the edge
                ctx.beginPath();
                ctx.arc(0, 0, radius - 5, i * anglePerSegment, (i + 1) * anglePerSegment);
                ctx.strokeStyle = colorPair.start + '55'; // 55 for transparency
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Add wheel rim/border
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#0FF';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Add glow to the rim
            ctx.beginPath();
            ctx.arc(0, 0, radius + 2, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Add an inner circle
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#222';
            ctx.fill();
            ctx.strokeStyle = '#0FF';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Add a cyberpunk-style center
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#0FF';
            ctx.fill();
            
            // Add names to segments
            const textRadius = 110;
            ctx.font = 'bold 20px "Share Tech Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i < numSegments; i++) {
                const angle = (i + 0.5) * anglePerSegment;
                const x = textRadius * Math.cos(angle);
                const y = textRadius * Math.sin(angle);
                
                ctx.save();
                ctx.translate(x, y);
                
                let textRotation = angle;
                if (angle > Math.PI/2 && angle < 3*Math.PI/2) {
                    textRotation += Math.PI;
                }
                
                ctx.rotate(textRotation);
                
                // Text glow
                ctx.strokeStyle = '#0FF';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.7;
                ctx.strokeText(names[i], 0, 0);
                ctx.globalAlpha = 1;
                
                // Main text in cyan
                ctx.fillStyle = '#FFF';
                ctx.fillText(names[i], 0, 0);
                
                ctx.restore();
            }
            
            ctx.translate(-centerX, -centerY);
        }

        // Draw the wheel once
        drawWheel();

        // Set up Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-200, 200, 200, -200, 1, 1000);
        camera.position.set(0, 0, 500);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(400, 400);
        document.getElementById('wheelContainer').appendChild(renderer.domElement);

        // Create wheel mesh from canvas texture
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const geometry = new THREE.CircleGeometry(radius, 64);
        const wheelMesh = new THREE.Mesh(geometry, material);
        scene.add(wheelMesh);

        // Spinning variables
        let isSpinning = false;
        let angularVelocity = 0;
        let deceleration = 0;

        const clock = new THREE.Clock();

        // Cyberpunk Fireworks class
        class Firework {
            constructor(x, y, targetX, targetY, color) {
                this.x = x;
                this.y = y;
                this.z = 0; // Add z-coordinate for depth
                this.targetX = targetX;
                this.targetY = targetY;
                this.targetZ = Math.random() * 50 - 25; // Random target depth
                this.color = color;
                this.speed = 2 + Math.random() * 3;
                this.angle = Math.atan2(targetY - y, targetX - x);
                this.radius = 2;
                this.exploded = false;
                this.particles = [];
                this.trail = [];
                this.maxTrailLength = 5;
            }
            
            update() {
                if (!this.exploded) {
                    // Add to trail before updating position
                    this.trail.push({x: this.x, y: this.y, z: this.z});
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                    
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    this.z += (this.targetZ - this.z) * 0.05; // Move toward target Z
                    
                    // Check if reached target
                    const distanceToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                    if (distanceToTarget < 10) {
                        this.explode();
                    }
                } else {
                    for (let i = 0; i < this.particles.length; i++) {
                        const p = this.particles[i];
                        
                        // Add digital-looking movement with more depth perception
                        if (Math.random() < 0.1) {
                            p.vx = p.vx * 0.8 + (Math.random() - 0.5) * 0.5;
                            p.vy = p.vy * 0.8 + (Math.random() - 0.5) * 0.5;
                            p.vz = p.vz * 0.8 + (Math.random() - 0.5) * 0.8; // More z-velocity variance
                        }
                        
                        p.x += p.vx;
                        p.y += p.vy;
                        p.z += p.vz;
                        
                        p.vy += 0.03; // reduced gravity for floaty effect
                        p.vz *= 0.98; // slight z-damping
                        p.life -= 0.01; // slower fade
                        
                        // Bounce effect for some particles to add depth perception
                        if (p.z > 50 && p.vz > 0) {
                            p.vz = -p.vz * 0.6;
                        } else if (p.z < -50 && p.vz < 0) {
                            p.vz = -p.vz * 0.6;
                        }
                        
                        if (p.life <= 0) {
                            this.particles.splice(i, 1);
                            i--;
                        }
                    }
                }
            }
            
            explode() {
                this.exploded = true;
                const particleCount = 150; // More particles for richer effect
                
                for (let i = 0; i < particleCount; i++) {
                    // Create digital pattern explosion with 3D effect
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = Math.random() * Math.PI - Math.PI / 2; // Full sphere of directions
                    const speed = 0.5 + Math.random() * 2;
                    
                    // Use neon colors for particles with variance in brightness
                    const colors = ['#0ff', '#f0f', '#0f0', '#ff0', '#f00', '#00f', '#fff'];
                    const particleColor = colors[Math.floor(Math.random() * colors.length)];
                    
                    // Some particles move in straight lines like digital pixels
                    const straightLine = Math.random() < 0.3;
                    const vx = straightLine ? 
                        (Math.random() < 0.5 ? speed : -speed) : 
                        Math.cos(angle) * Math.cos(elevation) * speed;
                    const vy = straightLine ? 
                        (Math.random() < 0.5 ? speed : -speed) : 
                        Math.sin(angle) * Math.cos(elevation) * speed;
                    const vz = straightLine ?
                        0 : Math.sin(elevation) * speed; // Z-velocity for 3D movement
                    
                    this.particles.push({
                        x: this.x,
                        y: this.y,
                        z: this.z,
                        vx: vx,
                        vy: vy,
                        vz: vz,
                        life: 0.8 + Math.random() * 0.4,
                        initialLife: 0.8 + Math.random() * 0.4, // Store initial life for scaling effects
                        color: particleColor,
                        size: 1 + Math.random() * 3,
                        square: Math.random() < 0.3, // some particles are squares
                        flicker: Math.random() < 0.2 // some particles flicker
                    });
                }
            }
            
            draw(ctx) {
                if (!this.exploded) {
                    // Draw trail
                    for (let i = 0; i < this.trail.length; i++) {
                        const alpha = i / this.trail.length;
                        const point = this.trail[i];
                        // Scale radius by z-position for depth
                        const scaleFactor = Math.max(0.5, Math.min(1.5, 1 + point.z / 100));
                        const renderRadius = this.radius * alpha * scaleFactor;
                        
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, renderRadius, 0, Math.PI * 2);
                        ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        ctx.fill();
                    }
                    
                    // Draw current position with z-based scaling
                    const currentScaleFactor = Math.max(0.5, Math.min(1.5, 1 + this.z / 100));
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * currentScaleFactor, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    
                    // Add glow effect - larger for "closer" objects
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, (this.radius + 2) * currentScaleFactor, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + '33'; // 33 for transparency
                    ctx.fill();
                } else {
                    // Sort particles by Z for proper depth rendering
                    const sortedParticles = [...this.particles].sort((a, b) => a.z - b.z);
                    
                    for (const p of sortedParticles) {
                        // Calculate size based on z-position for perspective effect
                        const scaleFactor = Math.max(0.3, Math.min(2.0, 1 + p.z / 70));
                        const renderSize = p.size * scaleFactor;
                        
                        // Add flicker effect to some particles
                        let alpha = p.life;
                        if (p.flicker && Math.random() < 0.3) {
                            alpha = Math.max(0.2, Math.random() * p.life);
                        }
                        
                        // Add motion blur for fast-moving particles
                        const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy + p.vz * p.vz);
                        if (speed > 1.5) {
                            // Draw motion trail
                            const trailLength = Math.min(3, Math.floor(speed * 1.5));
                            for (let i = 1; i <= trailLength; i++) {
                                const trailFactor = i / (trailLength + 1);
                                ctx.beginPath();
                                
                                if (p.square) {
                                    ctx.rect(
                                        p.x - trailFactor * p.vx - renderSize/2,
                                        p.y - trailFactor * p.vy - renderSize/2,
                                        renderSize, renderSize
                                    );
                                } else {
                                    ctx.arc(
                                        p.x - trailFactor * p.vx,
                                        p.y - trailFactor * p.vy,
                                        renderSize * (1 - trailFactor * 0.5),
                                        0, Math.PI * 2
                                    );
                                }
                                
                                ctx.fillStyle = p.color + Math.floor(alpha * 0.4 * (1 - trailFactor) * 255).toString(16).padStart(2, '0');
                                ctx.fill();
                            }
                        }
                        
                        ctx.beginPath();
                        
                        if (p.square) {
                            // Draw squares with slight rotation for dynamic feel
                            ctx.save();
                            ctx.translate(p.x, p.y);
                            ctx.rotate(p.vx * p.vy * 0.05);
                            ctx.rect(-renderSize/2, -renderSize/2, renderSize, renderSize);
                            ctx.restore();
                        } else {
                            // Draw circles for others
                            ctx.arc(p.x, p.y, renderSize, 0, Math.PI * 2);
                        }
                        
                        ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        ctx.fill();
                        
                        // Add glow/shadow effect based on z-position
                        if (p.life > 0.3) {
                            ctx.beginPath();
                            if (p.square) {
                                ctx.save();
                                ctx.translate(p.x, p.y);
                                ctx.rotate(p.vx * p.vy * 0.05);
                                ctx.rect(-renderSize/2 - 2, -renderSize/2 - 2, renderSize + 4, renderSize + 4);
                                ctx.restore();
                            } else {
                                ctx.arc(p.x, p.y, renderSize + 2 * scaleFactor, 0, Math.PI * 2);
                            }
                            // Adjust glow based on depth - brighter when "closer"
                            const glowAlpha = Math.floor((0.2 + 0.1 * scaleFactor) * 255).toString(16).padStart(2, '0');
                            ctx.fillStyle = p.color + glowAlpha;
                            ctx.fill();
                        }
                        
                        // Optional: Draw small shadow beneath particles to enhance depth perception
                        if (p.z > -20) {
                            const shadowDist = Math.max(0, (p.z + 50) / 5);
                            ctx.beginPath();
                            ctx.ellipse(
                                p.x + shadowDist/2,
                                p.y + shadowDist/2,
                                renderSize * 0.7,
                                renderSize * 0.3,
                                0, 0, Math.PI * 2
                            );
                            const shadowAlpha = Math.floor(0.2 * p.life * 255).toString(16).padStart(2, '0');
                            ctx.fillStyle = "#000" + shadowAlpha;
                            ctx.fill();
                        }
                    }
                }
            }
            
            isComplete() {
                return this.exploded && this.particles.length === 0;
            }
        }
        
        // Cyberpunk themed digital confetti
        class DigitalParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 5 + Math.random() * 10;
                // Use cyberpunk colors
                const colors = ['#0ff', '#f0f', '#0f0', '#00f', '#f00'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.speed = 1 + Math.random() * 3;
                this.angle = Math.random() * Math.PI * 2;
                this.spin = Math.random() * 0.2 - 0.1;
                this.rotation = Math.random() * Math.PI * 2;
                this.life = 1;
                this.isSquare = Math.random() < 0.5; // 50% chance of being a square
                
                // For digital movement (pixelated)
                this.moveTime = 0;
                this.moveInterval = 5 + Math.random() * 10;
                this.digitalMovement = Math.random() < 0.3;
            }
            
            update() {
                if (this.digitalMovement) {
                    this.moveTime++;
                    if (this.moveTime >= this.moveInterval) {
                        this.y += Math.floor(Math.random() * 5) * 5; // Move in 5px steps
                        this.x += (Math.random() < 0.5 ? -1 : 1) * Math.floor(Math.random() * 3) * 5;
                        this.moveTime = 0;
                        this.moveInterval = 5 + Math.random() * 10;
                    }
                } else {
                    this.y += this.speed;
                    this.x += Math.sin(this.angle) * 0.5;
                }
                
                this.rotation += this.spin;
                this.life -= 0.005;
                
                // Random flickering
                if (Math.random() < 0.05) {
                    this.life = Math.max(this.life, Math.random() * 0.3 + 0.7);
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const alpha = Math.floor(this.life * 255).toString(16).padStart(2, '0');
                
                if (this.isSquare) {
                    ctx.fillStyle = this.color + alpha;
                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                    
                    // Add pixel-like inner details for squares
                    if (this.size > 8) {
                        ctx.fillStyle = '#FFF' + alpha;
                        ctx.fillRect(-this.size/4, -this.size/4, this.size/2, this.size/2);
                    }
                } else {
                    // For circular particles, add a glow effect
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + alpha;
                    ctx.fill();
                    
                    // Glowing border
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size+2, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + '33'; // 33 for transparency
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            isComplete() {
                return this.life <= 0 || this.y > 400;
            }
        }

        // Fireworks effect manager with cyberpunk theme
        const effectsManager = {
            fireworks: [],
            digitalParticles: [],
            fireworksCanvas: document.getElementById('fireworksCanvas'),
            fireworksCtx: document.getElementById('fireworksCanvas').getContext('2d'),
            active: false,
            colors: ['#0ff', '#f0f', '#0f0', '#00f', '#f00'],
            
            startCelebration(selectedName) {
                this.active = true;
                this.fireworks = [];
                this.digitalParticles = [];
                
                // Play cyberpunk celebration sound
                this.playSound();
                
                // Launch initial fireworks
                this.launchFireworks(8); // More initial fireworks
                
                // Add digital particles
                this.addDigitalParticles(150);
                
                // Schedule additional effects
                this.timer = setInterval(() => {
                    if (this.fireworks.length < 5) {
                        this.launchFireworks(1 + Math.floor(Math.random() * 2));
                    }
                    
                    if (this.digitalParticles.length < 50) {
                        this.addDigitalParticles(20);
                    }
                    
                    // Stop after 5 seconds
                    if (this.celebrationTime > 5000) {
                        clearInterval(this.timer);
                    }
                }, 500);
                
                this.celebrationTime = 0;
                this.lastTime = Date.now();
                this.animateCelebration();
            },
            
            launchFireworks(count) {
                for (let i = 0; i < count; i++) {
                    const startX = Math.random() * 400;
                    const startY = 400;
                    const targetX = 100 + Math.random() * 200;
                    const targetY = 50 + Math.random() * 150;
                    const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                    this.fireworks.push(new Firework(startX, startY, targetX, targetY, color));
                }
            },
            
            addDigitalParticles(count) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * 400;
                    const y = -10;
                    this.digitalParticles.push(new DigitalParticle(x, y));
                }
            },
            
            playSound() {
                try {
                    // Cyberpunk-style sound effect
                    const audio = new Audio('https://assets.mixkit.co/active_storage/sfx/1688/1688-preview.mp3');
                    audio.volume = 0.3;
                    audio.play().catch(e => console.log('Sound play error:', e));
                } catch(e) {
                    console.log('Sound play error:', e);
                }
            },
            
            animateCelebration() {
                if (!this.active) return;
        
                const now = Date.now();
                const deltaTime = now - this.lastTime;
                this.lastTime = now;
                this.celebrationTime += deltaTime;
                
                // Clear the canvas
                this.fireworksCtx.clearRect(0, 0, 400, 400);
                
                // Update and draw fireworks
                for (let i = 0; i < this.fireworks.length; i++) {
                    this.fireworks[i].update();
                    this.fireworks[i].draw(this.fireworksCtx);
                    
                    if (this.fireworks[i].isComplete()) {
                        this.fireworks.splice(i, 1);
                        i--;
                    }
                }
                
                // Update and draw digital particles
                for (let i = 0; i < this.digitalParticles.length; i++) {
                    this.digitalParticles[i].update();
                    this.digitalParticles[i].draw(this.fireworksCtx);
                    
                    if (this.digitalParticles[i].isComplete()) {
                        this.digitalParticles.splice(i, 1);
                        i--;
                    }
                }
                
                // End celebration if time exceeds limit
                if (this.celebrationTime > 5000 && this.fireworks.length === 0 && this.digitalParticles.length === 0) {
                    this.active = false;
                    return;
                }
                
                requestAnimationFrame(() => this.animateCelebration());
            }
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (isSpinning) {
                wheelMesh.rotation.z += angularVelocity * delta;
                angularVelocity -= deceleration * delta;
                
                // Check if wheel is about to stop
                if (angularVelocity <= 0.1) {
                    // Calculate which name will be selected if we stop now
                    const theta = (wheelMesh.rotation.z % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                    const alpha = (theta + Math.PI*3/2) % (2 * Math.PI);
                    const segmentIndex = Math.floor(alpha / anglePerSegment);
                    const potentialName = names[segmentIndex];
                    
                    // If name already selected, continue spinning but FASTER
                    if (selectedNames.has(potentialName) && selectedNames.size < names.length) {
                        // Special case for the last remaining name - direct guidance
                        if (selectedNames.size == names.length - 1) {
                            // Find the only unselected name
                            let lastNameIndex = -1;
                            for (let i = 0; i < names.length; i++) {
                                if (!selectedNames.has(names[i])) {
                                    lastNameIndex = i;
                                    break;
                                }
                            }
                            
                            if (lastNameIndex >= 0) {
                                // Calculate how many segments we need to travel
                                let currentIndex = segmentIndex;
                                let segmentsToTravel = (lastNameIndex - currentIndex + names.length) % names.length;
                                
                                // Apply a precise boost based on distance
                                let targetVelocity = 0.3 + segmentsToTravel * 0.2; // Higher velocity for longer distance
                                angularVelocity = targetVelocity;
                                deceleration = 0.05 + segmentsToTravel * 0.02; // Slower deceleration for longer travel
                                
                                console.log(`Final name targeting: boosting to ${lastNameIndex} (${names[lastNameIndex]}) with velocity ${angularVelocity.toFixed(2)}`);
                            }
                        } else {
                            // Original boosting logic for non-final selections
                            const selectedRatio = selectedNames.size / names.length;
                            const boostMultiplier = 1 + selectedRatio * 2;
                            
                            angularVelocity = Math.max(0.5, angularVelocity) * boostMultiplier;
                            deceleration = 0.2;
                            
                            console.log(`Boosting past ${potentialName} with velocity ${angularVelocity.toFixed(2)}`);
                        }
                    }
                }
                
                // Stop the wheel
                if (angularVelocity <= 0) {
                    isSpinning = false;
                    angularVelocity = 0;
                    const theta = (wheelMesh.rotation.z % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                    const alpha = (theta + Math.PI*3/2) % (2 * Math.PI);
                    const segmentIndex = Math.floor(alpha / anglePerSegment);
                    const selectedName = names[segmentIndex];
                    
                    // Add to selected names set
                    selectedNames.add(selectedName);
                    console.log(`Selected: ${selectedName}, now have ${selectedNames.size}/${names.length} names`);
                    
                    // Update UI
                    const resultDiv = document.getElementById('result');
                    resultDiv.innerText = `>> ${selectedName} <<`;
                    resultDiv.classList.add('show');
                    
                    // Add to history
                    addToHistory(selectedName);
                    
                    // Start celebration effects
                    effectsManager.startCelebration(selectedName);
                    
                    // Update spin button state
                    updateSpinButtonState();
                }
            }
            renderer.render(scene, camera);
        }

        // Start the animation
        animate();

        // Spin button event
        document.getElementById('spinButton').addEventListener('click', () => {
            if (!isSpinning) {
                // Clear previous results
                const resultDiv = document.getElementById('result');
                resultDiv.innerText = '';
                resultDiv.classList.remove('show');
                effectsManager.fireworksCtx.clearRect(0, 0, 400, 400);
                
                // Add spinning sound
                try {
                    const spinSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2649/2649-preview.mp3');
                    spinSound.volume = 0.2;
                    spinSound.play().catch(e => console.log('Spin sound error:', e));
                } catch(e) {
                    console.log('Spin sound error:', e);
                }
                
                // Special handling for the last name
                if (selectedNames.size === names.length - 1) {
                    // Find the last remaining name
                    let lastRemainingName = null;
                    let lastNameIndex = -1;
                    
                    for (let i = 0; i < names.length; i++) {
                        if (!selectedNames.has(names[i])) {
                            lastRemainingName = names[i];
                            lastNameIndex = i;
                            break;
                        }
                    }
                    
                    if (lastRemainingName) {
                        console.log(`Last remaining name: ${lastRemainingName} at index ${lastNameIndex}`);
                        
                        // Pre-determine the landing spot - get the current angle
                        const currentAngle = wheelMesh.rotation.z % (2 * Math.PI);
                        
                        // Calculate the target angle for the last name
                        // We want the last name to end at the bottom (3π/2 from the top)
                        // But because we calculate from the top, we need to offset by π/2
                        const targetSegmentCenter = lastNameIndex * anglePerSegment + (anglePerSegment / 2);
                        // We need bottom position (3π/2) to align with the target segment
                        const targetAngle = -targetSegmentCenter + (3 * Math.PI / 2);
                        
                        // Calculate how many full rotations + the target angle (between 2-4 full rotations)
                        const fullRotations = 2 + Math.random() * 2; // 2-4 full rotations
                        const totalAngleToRotate = fullRotations * (2 * Math.PI) + (targetAngle - currentAngle);
                        
                        console.log(`Current: ${currentAngle.toFixed(2)}, Target: ${targetAngle.toFixed(2)}, Total: ${totalAngleToRotate.toFixed(2)}`);
                        
                        // Set appropriate velocity and deceleration to reach that exact position
                        // Higher velocity for more rotations, and deceleration tuned to stop at the right place
                        isSpinning = true;
                        angularVelocity = Math.max(2, totalAngleToRotate / 3); // Initial velocity based on distance
                        deceleration = angularVelocity * angularVelocity / (2 * totalAngleToRotate); // Physics formula: v²=2ad
                        
                        console.log(`Forced final spin: velocity=${angularVelocity.toFixed(2)}, deceleration=${deceleration.toFixed(4)}`);
                    } else {
                        // Fallback to normal spinning
                        isSpinning = true;
                        angularVelocity = 2 * Math.PI + Math.random() * Math.PI;
                        deceleration = 1 + Math.random() * 0.5;
                    }
                } else {
                    // Normal spinning for names 1-6
                    isSpinning = true;
                    angularVelocity = 2 * Math.PI + Math.random() * Math.PI;
                    deceleration = 1 + Math.random() * 0.5;
                }
            }
        });

        // Code Rain implementation (Matrix style)
        class CodeRain {
            constructor() {
                this.canvas = document.getElementById('codeRainCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // More authentic Matrix characters, including Katakana for authenticity
                this.symbols = "日ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍｦｲｸｺｿﾁﾄﾉﾌﾔﾖﾙﾚﾛﾝ012345789:・.\"*=+<>¦｜╌ ｸﾘｽﾄﾌｧｰ";
                this.fontSize = 14;
                this.drops = [];
                this.speeds = []; // Different speeds for different columns
                this.highlights = []; // For highlighted characters
                this.lastUpdate = Date.now(); // For controlling animation speed
                this.updateInterval = 65; // Slower update interval (milliseconds)
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Start the animation
                this.draw();
            }
            
            initialize() {
                // Initialize drops at random positions
                const oldLength = this.drops.length;
                
                // Resize arrays if needed
                if (this.columns > oldLength) {
                    for (let i = oldLength; i < this.columns; i++) {
                        // Place drops at random distances above the screen
                        this.drops[i] = -Math.floor(Math.random() * 50);
                        
                        // Different speeds for different columns
                        this.speeds[i] = 0.1 + Math.random() * 0.3; // Much slower speeds
                        
                        // Random chance to highlight (matrix style bright characters)
                        this.highlights[i] = Math.random() < 0.1; // 10% chance for highlighted column
                    }
                }
                
                // Ensure we don't have too many drops
                this.drops = this.drops.slice(0, this.columns);
                this.speeds = this.speeds.slice(0, this.columns);
                this.highlights = this.highlights.slice(0, this.columns);
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.columns = Math.floor(this.canvas.width / this.fontSize);
                this.initialize();
            }
            
            draw() {
                // Animate based on time passed, not frame rate
                const now = Date.now();
                const delta = now - this.lastUpdate;
                
                if (delta > this.updateInterval) {
                    this.lastUpdate = now;
                    
                    // Darker, more Matrix-like semi-transparent black to create fade effect
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.07)"; // Slower fade
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Set text properties
                    this.ctx.font = this.fontSize + "px 'Share Tech Mono', monospace";
                    
                    for (let i = 0; i < this.columns; i++) {
                        // Move drops based on their individual speeds
                        this.drops[i] += this.speeds[i];
                        
                        // Get the current position in the grid
                        const y = Math.floor(this.drops[i]) * this.fontSize;
                        
                        if (y >= 0 && y < this.canvas.height + this.fontSize) {
                            // Random character
                            const text = this.symbols.charAt(Math.floor(Math.random() * this.symbols.length));
                            
                            // Lead character is white or very bright
                            if (this.highlights[i]) {
                                // Highlighted column with brighter lead character
                                this.ctx.fillStyle = "rgba(220, 255, 255, 0.9)";
                            } else {
                                // Regular column
                                if (Math.random() < 0.98) {
                                    this.ctx.fillStyle = "rgba(0, 255, 150, 0.9)"; // Matrix green
                                } else {
                                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.95)"; // Occasional bright character
                                }
                            }
                            
                            // Draw lead character
                            this.ctx.fillText(text, i * this.fontSize, y);
                            
                            // Draw trailing characters with fading effect
                            for (let j = 1; j < 25; j++) {
                                if (y - j * this.fontSize >= 0) {
                                    // Get a new symbol for this position
                                    const trailText = this.symbols.charAt(Math.floor(Math.random() * this.symbols.length));
                                    
                                    // Calculate alpha based on position in the trail
                                    let alpha = Math.max(0, 1 - (j / 25)) * 0.8;
                                    
                                    // Highlighted columns have slightly brighter trails
                                    if (this.highlights[i]) {
                                        this.ctx.fillStyle = `rgba(0, 255, 200, ${alpha * 1.3})`;
                                    } else {
                                        this.ctx.fillStyle = `rgba(0, 255, 150, ${alpha})`;
                                    }
                                    
                                    // 5% chance to change character even in the trail
                                    if (Math.random() < 0.05) {
                                        this.ctx.fillText(
                                            trailText, 
                                            i * this.fontSize, 
                                            y - j * this.fontSize
                                        );
                                    } else {
                                        // Draw existing character with fading opacity
                                        this.ctx.fillText(
                                            trailText, 
                                            i * this.fontSize, 
                                            y - j * this.fontSize
                                        );
                                    }
                                }
                            }
                        }
                        
                        // Reset drops when they're far enough down screen
                        if (y > this.canvas.height * 1.5) {
                            // Respawn at different times
                            if (Math.random() > 0.99) {
                                this.drops[i] = -Math.floor(Math.random() * 20); // Start above the screen
                                this.speeds[i] = 0.1 + Math.random() * 0.3; // Assign a new speed
                                this.highlights[i] = Math.random() < 0.1; // Recalculate highlight status
                            }
                        }
                        
                        // Occasionally change the speed slightly for natural movement
                        if (Math.random() < 0.002) {
                            this.speeds[i] = Math.max(0.05, Math.min(0.5, this.speeds[i] + (Math.random() - 0.5) * 0.1));
                        }
                    }
                    
                    // Occasionally add a new drop
                    if (Math.random() < 0.05 && this.drops.length < this.columns) {
                        const i = Math.floor(Math.random() * this.columns);
                        if (!this.drops[i] || this.drops[i] * this.fontSize > this.canvas.height) {
                            this.drops[i] = -1;
                            this.speeds[i] = 0.1 + Math.random() * 0.3;
                            this.highlights[i] = Math.random() < 0.1;
                        }
                    }
                }
                
                // Always request next animation frame to keep the loop running
                requestAnimationFrame(() => this.draw());
            }
        }
        
        // Initialize code rain
        const codeRain = new CodeRain();
        
        // History management functions
        function addToHistory(name) {
            const historyList = document.getElementById('historyList');
            const item = document.createElement('li');
            item.classList.add('history-item');
            
            // Create timestamp
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
            
            // Create main content with cyberpunk styling
            item.innerHTML = `
                <span>// ${name}</span>
                <span class="timestamp">${timeString}</span>
            `;
            
            // Add to the beginning of the list
            historyList.insertBefore(item, historyList.firstChild);
            
            // Save to localStorage
            saveHistoryToStorage();
        }
        
        function clearHistory() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            
            // Clear from localStorage
            localStorage.removeItem('wheelHistory');
        }
        
        function saveHistoryToStorage() {
            const historyList = document.getElementById('historyList');
            const historyItems = Array.from(historyList.children).map(item => {
                return {
                    name: item.querySelector('span:first-child').textContent.substring(3), // Remove the "// " prefix
                    time: item.querySelector('.timestamp').textContent
                };
            });
            
            localStorage.setItem('wheelHistory', JSON.stringify(historyItems));
        }
        
        function loadHistoryFromStorage() {
            const historyList = document.getElementById('historyList');
            const savedHistory = localStorage.getItem('wheelHistory');
            
            if (savedHistory) {
                const historyItems = JSON.parse(savedHistory);
                
                historyItems.forEach(item => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('history-item');
                    listItem.innerHTML = `
                        <span>// ${item.name}</span>
                        <span class="timestamp">${item.time}</span>
                    `;
                    historyList.appendChild(listItem);
                });
            }
        }
        
        // Clear history button event
        document.getElementById('clearHistory').addEventListener('click', () => {
            clearHistory();
            // Clear selected names and re-enable spin button
            selectedNames.clear();
            updateSpinButtonState();
        });
        
        // Load history on page load and update selectedNames set
        window.onload = function() {
            loadHistoryFromStorage();
            
            // Initialize selectedNames from existing history
            const historyList = document.getElementById('historyList');
            if (historyList.children.length > 0) {
                Array.from(historyList.children).forEach(item => {
                    const name = item.querySelector('span:first-child').textContent.substring(3); // Remove "// " prefix
                    selectedNames.add(name);
                    console.log(`Added from history: ${name}`);
                });
            }
            
            console.log(`Loaded ${selectedNames.size}/${names.length} names from history`);
            // Update button state based on loaded history
            updateSpinButtonState();
        };

        // Function to check if all names have been selected and update button state
        function updateSpinButtonState() {
            const spinButton = document.getElementById('spinButton');
            
            // Check if all names have been selected
            if (selectedNames.size >= names.length) {
                console.log("All names selected, disabling button");
                spinButton.disabled = true;
                spinButton.title = "All names have been selected. Clear history to spin again.";
            } else {
                console.log(`${selectedNames.size}/${names.length} names selected, button enabled`);
                spinButton.disabled = false;
                spinButton.title = "Spin the wheel to select a random name";
            }
        }
    </script>
</body>
</html>