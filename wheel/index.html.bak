<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dev-Ops Wheel of Fate</title>
    <!-- Favicon -->
    <link rel="icon" href="logo.ico" type="image/x-icon">
    <link rel="shortcut icon" href="logo.ico" type="image/x-icon">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background: #0a0a0f;
            color: #e0e0ff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }
        
        body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(32, 68, 153, 0.15), rgba(10, 10, 15, 0.3));
            pointer-events: none;
            z-index: -1;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .content-row {
            display: flex;
            flex-wrap: nowrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }
        
        .wheel-section {
            flex: 0 0 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .wheel-section::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: linear-gradient(45deg, #0ff 0%, #f0f 50%, #0ff 100%);
            z-index: -1;
            filter: blur(15px);
            opacity: 0.5;
            border-radius: 20px;
            animation: neonPulse 3s infinite alternate;
        }
        
        @keyframes neonPulse {
            0% { opacity: 0.3; }
            100% { opacity: 0.7; }
        }
        
        .history-section {
            flex: 0 0 300px;
            background: rgba(25, 25, 35, 0.8);
            border: 1px solid #0ff;
            box-shadow: 0 0 15px #0ff5, 0 0 30px #0ff3;
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 400px;
            align-self: flex-start;
            margin-top: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .history-section::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #0ff, #f0f);
            filter: blur(1px);
        }
        
        .history-title {
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 15px #0ff8;
            margin-top: 0;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }
        
        .history-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        
        .history-item {
            background: rgba(40, 40, 60, 0.5);
            margin-bottom: 10px;
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 2px solid #0ff;
            display: flex;
            align-items: center;
            animation: slideIn 0.3s ease-out forwards;
            transform: translateX(50px);
            opacity: 0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        
        @keyframes slideIn {
            to { transform: translateX(0); opacity: 1; }
        }
        
        .history-item .timestamp {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-left: auto;
            font-family: 'Share Tech Mono', monospace;
            color: #f0f;
        }
        
        .clear-button {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(45deg, #222 0%, #333 100%);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            box-shadow: 0 0 10px #0ff5;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .clear-button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            transform: rotate(45deg);
            transition: all 0.5s ease;
        }
        
        .clear-button:hover {
            color: #fff;
            box-shadow: 0 0 20px #0ff;
        }
        
        .clear-button:hover::after {
            left: 100%;
        }
        
        .clear-button:active {
            transform: translateY(1px);
            box-shadow: 0 0 5px #0ff;
        }
        
        @media (max-width: 800px) {
            .content-row {
                flex-direction: column;
                align-items: center;
            }
            
            .history-section {
                width: 90%;
                margin-top: 20px;
                height: 300px;
                align-self: center;
            }
        }
        
        .title {
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            font-size: 2.8rem;
            margin-bottom: 30px;
            color: #fff;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5;
            position: relative;
            animation: glitch 5s infinite;
        }
        
        @keyframes glitch {
            0% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; }
            2% { text-shadow: 2px 0 10px #0ff, -2px 0 10px #f0f; transform: translateX(-2px); }
            3% { text-shadow: -2px 0 10px #0ff, 2px 0 10px #f0f; transform: translateX(2px); }
            4% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; transform: translateX(0); }
            42% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; }
            43% { text-shadow: 2px 0 10px #0ff, -2px 0 10px #f0f; transform: translateX(3px); }
            44% { text-shadow: -2px 0 10px #0ff, 2px 0 10px #f0f; transform: translateX(-3px); }
            45% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; transform: translateX(0); }
            100% { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f5; }
        }
        
        #wheelContainer {
            width: 400px;
            height: 400px;
            margin: 30px auto;
            position: relative;
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            transform-style: preserve-3d;
            overflow: hidden;
            border: 3px solid #333;
        }
        
        #spinButton {
            display: block;
            margin: 30px auto;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(45deg, #222 0%, #333 100%);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }
        
        #spinButton::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s ease;
        }
        
        #spinButton:hover {
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        #spinButton:hover::after {
            left: 100%;
        }
        
        #spinButton:active {
            transform: translateY(1px);
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.4);
        }
        
        /* Add disabled button style */
        #spinButton:disabled {
            background: linear-gradient(45deg, #222 0%, #333 100%);
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7;
        }
        
        #spinButton:disabled::after {
            display: none;
        }
        
        #result {
            text-align: center;
            font-size: 2rem;
            margin-top: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #0ff;
            min-height: 60px;
            opacity: 0;
            transition: opacity 0.5s ease;
            font-family: 'Orbitron', sans-serif;
        }
        
        #result.show {
            animation: popIn 0.5s forwards, neonFlicker 2s 0.5s infinite;
            opacity: 1;
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes neonFlicker {
            0% { text-shadow: 0 0 10px #0ff; }
            5% { text-shadow: 0 0 15px #0ff; }
            10% { text-shadow: 0 0 5px #0ff; }
            15% { text-shadow: 0 0 10px #0ff; }
            80% { text-shadow: 0 0 10px #0ff; }
            85% { text-shadow: 0 0 15px #0ff; }
            95% { text-shadow: 0 0 5px #0ff; }
            100% { text-shadow: 0 0 10px #0ff; }
        }
        
        #fireworksCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #codeRainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -10;
            opacity: 0.5;
        }
        
        .wheel-pointer {
            position: absolute;
            width: 30px;
            height: 50px;
            top: -20px;
            left: calc(50% - 15px);
            background-color: #f0f;
            clip-path: polygon(50% 0, 0% 100%, 100% 100%);
            z-index: 10;
            filter: drop-shadow(0 0 10px #f0f);
        }

        /* Version number styling */
        .version {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.8rem;
            color: #0ff;
            opacity: 0.7;
            text-shadow: 0 0 5px #0ff;
            z-index: 100;
            pointer-events: none;
        }
        
        .version:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Hidden canvas for drawing the wheel texture -->
    <canvas id="wheelCanvas" width="400" height="400" style="display: none;"></canvas>
    
    <!-- Matrix-style code rain canvas -->
    <canvas id="codeRainCanvas"></canvas>
    
    <div class="container">
        <h1 class="title">DEV-OPS WHEEL OF FATE</h1>
        
        <div class="content-row">
            <div class="wheel-section">
                <!-- Wheel section -->
                <div id="wheelContainer">
                    <!-- Canvas for fireworks/effects on top of the wheel -->
                    <canvas id="fireworksCanvas" width="400" height="400"></canvas>
                    <div class="wheel-pointer"></div>
                </div>
                
                <!-- Button to start spinning -->
                <button id="spinButton">INITIALIZE SELECTION</button>
                
                <!-- Display for the selected name -->
                <div id="result"></div>
            </div>
            
            <!-- History tracking section -->
            <div class="history-section">
                <h2 class="history-title">SELECTION LOG</h2>
                <ul id="historyList" class="history-list"></ul>
                <button id="clearHistory" class="clear-button">PURGE LOG</button>
            </div>
        </div>
    </div>
    
    <!-- Container for full-screen celebration effects -->
    <div id="celebrationContainer" class="celebration"></div>

    <!-- Version number -->
    <div class="version">v3.1.1</div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Get the canvas and context
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        // List of teammates - reversed to align with pointer at bottom
        const names = ['Ronnie', 'Jake', 'Kuldeep', 'Somesh', 'Matt', 'Jeff', 'Travis'];
        // Add a set to track selected names
        const selectedNames = new Set();
        const numSegments = names.length;
        const anglePerSegment = 2 * Math.PI / numSegments;
        const radius = 180;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Function to draw the wheel on the canvas
        function drawWheel() {
            ctx.translate(centerX, centerY);
            
            // Cyberpunk colors with gradients
            const colorPairs = [
                {start: '#00FFFF', end: '#0088FF'},
                {start: '#FF00FF', end: '#CC00FF'},
                {start: '#00FF99', end: '#00CCFF'},
                {start: '#FF0099', end: '#CC00FF'},
                {start: '#9900FF', end: '#6600FF'},
                {start: '#00CCFF', end: '#0066FF'},
                {start: '#FF00CC', end: '#CC0099'}
            ];
            
            // Draw each segment with gradient
            for (let i = 0; i < numSegments; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius, i * anglePerSegment, (i + 1) * anglePerSegment);
                ctx.closePath();
                
                // Create gradient for this segment
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                const colorPair = colorPairs[i % colorPairs.length];
                gradient.addColorStop(0, '#111');
                gradient.addColorStop(0.7, '#222');
                gradient.addColorStop(0.9, colorPair.start);
                gradient.addColorStop(1, colorPair.end);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Add a glowing effect at the edge
                ctx.beginPath();
                ctx.arc(0, 0, radius - 5, i * anglePerSegment, (i + 1) * anglePerSegment);
                ctx.strokeStyle = colorPair.start + '55'; // 55 for transparency
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Add wheel rim/border
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#0FF';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Add glow to the rim
            ctx.beginPath();
            ctx.arc(0, 0, radius + 2, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Add an inner circle
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#222';
            ctx.fill();
            ctx.strokeStyle = '#0FF';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Add a cyberpunk-style center
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#0FF';
            ctx.fill();
            
            // Add names to segments
            const textRadius = 110;
            ctx.font = 'bold 20px "Share Tech Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i < numSegments; i++) {
                const angle = (i + 0.5) * anglePerSegment;
                const x = textRadius * Math.cos(angle);
                const y = textRadius * Math.sin(angle);
                
                ctx.save();
                ctx.translate(x, y);
                
                let textRotation = angle;
                if (angle > Math.PI/2 && angle < 3*Math.PI/2) {
                    textRotation += Math.PI;
                }
                
                ctx.rotate(textRotation);
                
                // Text glow
                ctx.strokeStyle = '#0FF';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.7;
                ctx.strokeText(names[i], 0, 0);
                ctx.globalAlpha = 1;
                
                // Main text in cyan
                ctx.fillStyle = '#FFF';
                ctx.fillText(names[i], 0, 0);
                
                ctx.restore();
            }
            
            ctx.translate(-centerX, -centerY);
        }

        // Draw the wheel once
        drawWheel();

        // Set up Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-200, 200, 200, -200, 1, 1000);
        camera.position.set(0, 0, 500);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(400, 400);
        document.getElementById('wheelContainer').appendChild(renderer.domElement);

        // Create wheel mesh from canvas texture
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const geometry = new THREE.CircleGeometry(radius, 64);
        const wheelMesh = new THREE.Mesh(geometry, material);
        scene.add(wheelMesh);

        // Spinning variables
        let isSpinning = false;
        let angularVelocity = 0;
        let deceleration = 0;

        const clock = new THREE.Clock();

        // Cyberpunk Fireworks class
        class Firework {
            constructor(x, y, targetX, targetY, color) {
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.color = color;
                this.speed = 2 + Math.random() * 3;
                this.angle = Math.atan2(targetY - y, targetX - x);
                this.radius = 2;
                this.exploded = false;
                this.particles = [];
                this.trail = [];
                this.maxTrailLength = 5;
            }
            
            update() {
                if (!this.exploded) {
                    // Add to trail before updating position
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                    
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    
                    // Check if reached target
                    const distanceToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                    if (distanceToTarget < 10) {
                        this.explode();
                    }
                } else {
                    for (let i = 0; i < this.particles.length; i++) {
                        const p = this.particles[i];
                        
                        // Add digital-looking movement
                        if (Math.random() < 0.1) {
                            p.vx = p.vx * 0.8 + (Math.random() - 0.5) * 0.5;
                            p.vy = p.vy * 0.8 + (Math.random() - 0.5) * 0.5;
                        }
                        
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.03; // reduced gravity for floaty effect
                        p.life -= 0.01; // slower fade
                        
                        if (p.life <= 0) {
                            this.particles.splice(i, 1);
                            i--;
                        }
                    }
                }
            }
            
            explode() {
                this.exploded = true;
                const particleCount = 100; // more particles
                
                for (let i = 0; i < particleCount; i++) {
                    // Create digital pattern explosion
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.5 + Math.random() * 2;
                    
                    // Use neon colors for particles
                    const colors = ['#0ff', '#f0f', '#0f0', '#ff0', '#f00', '#00f'];
                    const particleColor = colors[Math.floor(Math.random() * colors.length)];
                    
                    // Some particles move in straight lines like digital pixels
                    const straightLine = Math.random() < 0.3;
                    const vx = straightLine ? 
                        (Math.random() < 0.5 ? speed : -speed) : 
                        Math.cos(angle) * speed;
                    const vy = straightLine ? 
                        (Math.random() < 0.5 ? speed : -speed) : 
                        Math.sin(angle) * speed;
                    
                    this.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: vx,
                        vy: vy,
                        life: 0.8 + Math.random() * 0.4,
                        color: particleColor,
                        size: 1 + Math.random() * 3,
                        square: Math.random() < 0.3 // some particles are squares
                    });
                }
            }
            
            draw(ctx) {
                if (!this.exploded) {
                    // Draw trail
                    for (let i = 0; i < this.trail.length; i++) {
                        const alpha = i / this.trail.length;
                        ctx.beginPath();
                        ctx.arc(this.trail[i].x, this.trail[i].y, this.radius * alpha, 0, Math.PI * 2);
                        ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        ctx.fill();
                    }
                    
                    // Draw current position
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + '33'; // 33 for transparency
                    ctx.fill();
                } else {
                    for (const p of this.particles) {
                        ctx.beginPath();
                        
                        if (p.square) {
                            // Draw squares for some particles
                            ctx.rect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                        } else {
                            // Draw circles for others
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        }
                        
                        ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16).padStart(2, '0');
                        ctx.fill();
                        
                        // Add glow to particles
                        if (p.life > 0.5) {
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size + 2, 0, Math.PI * 2);
                            ctx.fillStyle = p.color + '33'; // transparent glow
                            ctx.fill();
                        }
                    }
                }
            }
            
            isComplete() {
                return this.exploded && this.particles.length === 0;
            }
        }
        
        // Cyberpunk themed digital confetti
        class DigitalParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 5 + Math.random() * 10;
                // Use cyberpunk colors
                const colors = ['#0ff', '#f0f', '#0f0', '#00f', '#f00'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.speed = 1 + Math.random() * 3;
                this.angle = Math.random() * Math.PI * 2;
                this.spin = Math.random() * 0.2 - 0.1;
                this.rotation = Math.random() * Math.PI * 2;
                this.life = 1;
                this.isSquare = Math.random() < 0.5; // 50% chance of being a square
                
                // For digital movement (pixelated)
                this.moveTime = 0;
                this.moveInterval = 5 + Math.random() * 10;
                this.digitalMovement = Math.random() < 0.3;
            }
            
            update() {
                if (this.digitalMovement) {
                    this.moveTime++;
                    if (this.moveTime >= this.moveInterval) {
                        this.y += Math.floor(Math.random() * 5) * 5; // Move in 5px steps
                        this.x += (Math.random() < 0.5 ? -1 : 1) * Math.floor(Math.random() * 3) * 5;
                        this.moveTime = 0;
                        this.moveInterval = 5 + Math.random() * 10;
                    }
                } else {
                    this.y += this.speed;
                    this.x += Math.sin(this.angle) * 0.5;
                }
                
                this.rotation += this.spin;
                this.life -= 0.005;
                
                // Random flickering
                if (Math.random() < 0.05) {
                    this.life = Math.max(this.life, Math.random() * 0.3 + 0.7);
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const alpha = Math.floor(this.life * 255).toString(16).padStart(2, '0');
                
                if (this.isSquare) {
                    ctx.fillStyle = this.color + alpha;
                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                    
                    // Add pixel-like inner details for squares
                    if (this.size > 8) {
                        ctx.fillStyle = '#FFF' + alpha;
                        ctx.fillRect(-this.size/4, -this.size/4, this.size/2, this.size/2);
                    }
                } else {
                    // For circular particles, add a glow effect
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + alpha;
                    ctx.fill();
                    
                    // Glowing border
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size+2, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + '33'; // 33 for transparency
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            isComplete() {
                return this.life <= 0 || this.y > 400;
            }
        }

        // Fireworks effect manager with cyberpunk theme
        const effectsManager = {
            fireworks: [],
            digitalParticles: [],
            fireworksCanvas: document.getElementById('fireworksCanvas'),
            fireworksCtx: document.getElementById('fireworksCanvas').getContext('2d'),
            active: false,
            colors: ['#0ff', '#f0f', '#0f0', '#00f', '#f00'],
            
            startCelebration(selectedName) {
                this.active = true;
                this.fireworks = [];
                this.digitalParticles = [];
                
                // Play cyberpunk celebration sound
                this.playSound();
                
                // Launch initial fireworks
                this.launchFireworks(8); // More initial fireworks
                
                // Add digital particles
                this.addDigitalParticles(150);
                
                // Schedule additional effects
                this.timer = setInterval(() => {
                    if (this.fireworks.length < 5) {
                        this.launchFireworks(1 + Math.floor(Math.random() * 2));
                    }
                    
                    if (this.digitalParticles.length < 50) {
                        this.addDigitalParticles(20);
                    }
                    
                    // Stop after 5 seconds
                    if (this.celebrationTime > 5000) {
                        clearInterval(this.timer);
                    }
                }, 500);
                
                this.celebrationTime = 0;
                this.lastTime = Date.now();
                this.animateCelebration();
            },
            
            launchFireworks(count) {
                for (let i = 0; i < count; i++) {
                    const startX = Math.random() * 400;
                    const startY = 400;
                    const targetX = 100 + Math.random() * 200;
                    const targetY = 50 + Math.random() * 150;
                    const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                    this.fireworks.push(new Firework(startX, startY, targetX, targetY, color));
                }
            },
            
            addDigitalParticles(count) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * 400;
                    const y = -10;
                    this.digitalParticles.push(new DigitalParticle(x, y));
                }
            },
            
            playSound() {
                try {
                    // Cyberpunk-style sound effect
                    const audio = new Audio('https://assets.mixkit.co/active_storage/sfx/1688/1688-preview.mp3');
                    audio.volume = 0.3;
                    audio.play().catch(e => console.log('Sound play error:', e));
                } catch(e) {
                    console.log('Sound play error:', e);
                }
            },
            
            animateCelebration() {
                if (!this.active) return;
        
                const now = Date.now();
                const deltaTime = now - this.lastTime;
                this.lastTime = now;
                this.celebrationTime += deltaTime;
                
                // Clear the canvas
                this.fireworksCtx.clearRect(0, 0, 400, 400);
                
                // Update and draw fireworks
                for (let i = 0; i < this.fireworks.length; i++) {
                    this.fireworks[i].update();
                    this.fireworks[i].draw(this.fireworksCtx);
                    
                    if (this.fireworks[i].isComplete()) {
                        this.fireworks.splice(i, 1);
                        i--;
                    }
                }
                
                // Update and draw digital particles
                for (let i = 0; i < this.digitalParticles.length; i++) {
                    this.digitalParticles[i].update();
                    this.digitalParticles[i].draw(this.fireworksCtx);
                    
                    if (this.digitalParticles[i].isComplete()) {
                        this.digitalParticles.splice(i, 1);
                        i--;
                    }
                }
                
                // End celebration if time exceeds limit
                if (this.celebrationTime > 5000 && this.fireworks.length === 0 && this.digitalParticles.length === 0) {
                    this.active = false;
                    return;
                }
                
                requestAnimationFrame(() => this.animateCelebration());
            }
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (isSpinning) {
                wheelMesh.rotation.z += angularVelocity * delta;
                angularVelocity -= deceleration * delta;
                
                // Check if wheel is about to stop
                if (angularVelocity <= 0.1) {
                    // Calculate which name will be selected if we stop now
                    const theta = (wheelMesh.rotation.z % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                    const alpha = (theta + Math.PI*3/2) % (2 * Math.PI);
                    const segmentIndex = Math.floor(alpha / anglePerSegment);
                    const potentialName = names[segmentIndex];
                    
                    // If name already selected, continue spinning but slower
                    if (selectedNames.has(potentialName) && selectedNames.size < names.length) {
                        // Give it a small boost to continue past this segment
                        angularVelocity = Math.max(0.2, angularVelocity);
                        deceleration = 0.05; // Slower deceleration to be more subtle
                    }
                }
                
                // Stop the wheel
                if (angularVelocity <= 0) {
                    isSpinning = false;
                    angularVelocity = 0;
                    const theta = (wheelMesh.rotation.z % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                    const alpha = (theta + Math.PI*3/2) % (2 * Math.PI);
                    const segmentIndex = Math.floor(alpha / anglePerSegment);
                    const selectedName = names[segmentIndex];
                    
                    // Add to selected names set
                    selectedNames.add(selectedName);
                    console.log(`Selected: ${selectedName}, now have ${selectedNames.size}/${names.length} names`);
                    
                    // Update UI
                    const resultDiv = document.getElementById('result');
                    resultDiv.innerText = `>> ${selectedName} <<`;
                    resultDiv.classList.add('show');
                    
                    // Add to history
                    addToHistory(selectedName);
                    
                    // Start celebration effects
                    effectsManager.startCelebration(selectedName);
                    
                    // Update spin button state
                    updateSpinButtonState();
                }
            }
            renderer.render(scene, camera);
        }

        // Start the animation
        animate();

        // Spin button event
        document.getElementById('spinButton').addEventListener('click', () => {
            if (!isSpinning) {
                // Clear previous results
                const resultDiv = document.getElementById('result');
                resultDiv.innerText = '';
                resultDiv.classList.remove('show');
                effectsManager.fireworksCtx.clearRect(0, 0, 400, 400);
                
                // Add spinning sound
                try {
                    const spinSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2649/2649-preview.mp3');
                    spinSound.volume = 0.2;
                    spinSound.play().catch(e => console.log('Spin sound error:', e));
                } catch(e) {
                    console.log('Spin sound error:', e);
                }
                
                isSpinning = true;
                angularVelocity = 2 * Math.PI + Math.random() * Math.PI;
                deceleration = 1 + Math.random() * 0.5;
            }
        });

        // Code Rain implementation (Matrix style)
        class CodeRain {
            constructor() {
                this.canvas = document.getElementById('codeRainCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // More authentic Matrix characters, including Katakana for authenticity
                this.symbols = "日ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍｦｲｸｺｿﾁﾄﾉﾌﾔﾖﾙﾚﾛﾝ012345789:・.\"*=+<>¦｜╌ ｸﾘｽﾄﾌｧｰ";
                this.fontSize = 14;
                this.drops = [];
                this.speeds = []; // Different speeds for different columns
                this.highlights = []; // For highlighted characters
                this.lastUpdate = Date.now(); // For controlling animation speed
                this.updateInterval = 65; // Slower update interval (milliseconds)
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Start the animation
                this.draw();
            }
            
            initialize() {
                // Initialize drops at random positions
                const oldLength = this.drops.length;
                
                // Resize arrays if needed
                if (this.columns > oldLength) {
                    for (let i = oldLength; i < this.columns; i++) {
                        // Place drops at random distances above the screen
                        this.drops[i] = -Math.floor(Math.random() * 50);
                        
                        // Different speeds for different columns
                        this.speeds[i] = 0.1 + Math.random() * 0.3; // Much slower speeds
                        
                        // Random chance to highlight (matrix style bright characters)
                        this.highlights[i] = Math.random() < 0.1; // 10% chance for highlighted column
                    }
                }
                
                // Ensure we don't have too many drops
                this.drops = this.drops.slice(0, this.columns);
                this.speeds = this.speeds.slice(0, this.columns);
                this.highlights = this.highlights.slice(0, this.columns);
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.columns = Math.floor(this.canvas.width / this.fontSize);
                this.initialize();
            }
            
            draw() {
                // Animate based on time passed, not frame rate
                const now = Date.now();
                const delta = now - this.lastUpdate;
                
                if (delta > this.updateInterval) {
                    this.lastUpdate = now;
                    
                    // Darker, more Matrix-like semi-transparent black to create fade effect
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.07)"; // Slower fade
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Set text properties
                    this.ctx.font = this.fontSize + "px 'Share Tech Mono', monospace";
                    
                    for (let i = 0; i < this.columns; i++) {
                        // Move drops based on their individual speeds
                        this.drops[i] += this.speeds[i];
                        
                        // Get the current position in the grid
                        const y = Math.floor(this.drops[i]) * this.fontSize;
                        
                        if (y >= 0 && y < this.canvas.height + this.fontSize) {
                            // Random character
                            const text = this.symbols.charAt(Math.floor(Math.random() * this.symbols.length));
                            
                            // Lead character is white or very bright
                            if (this.highlights[i]) {
                                // Highlighted column with brighter lead character
                                this.ctx.fillStyle = "rgba(220, 255, 255, 0.9)";
                            } else {
                                // Regular column
                                if (Math.random() < 0.98) {
                                    this.ctx.fillStyle = "rgba(0, 255, 150, 0.9)"; // Matrix green
                                } else {
                                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.95)"; // Occasional bright character
                                }
                            }
                            
                            // Draw lead character
                            this.ctx.fillText(text, i * this.fontSize, y);
                            
                            // Draw trailing characters with fading effect
                            for (let j = 1; j < 25; j++) {
                                if (y - j * this.fontSize >= 0) {
                                    // Get a new symbol for this position
                                    const trailText = this.symbols.charAt(Math.floor(Math.random() * this.symbols.length));
                                    
                                    // Calculate alpha based on position in the trail
                                    let alpha = Math.max(0, 1 - (j / 25)) * 0.8;
                                    
                                    // Highlighted columns have slightly brighter trails
                                    if (this.highlights[i]) {
                                        this.ctx.fillStyle = `rgba(0, 255, 200, ${alpha * 1.3})`;
                                    } else {
                                        this.ctx.fillStyle = `rgba(0, 255, 150, ${alpha})`;
                                    }
                                    
                                    // 5% chance to change character even in the trail
                                    if (Math.random() < 0.05) {
                                        this.ctx.fillText(
                                            trailText, 
                                            i * this.fontSize, 
                                            y - j * this.fontSize
                                        );
                                    } else {
                                        // Draw existing character with fading opacity
                                        this.ctx.fillText(
                                            trailText, 
                                            i * this.fontSize, 
                                            y - j * this.fontSize
                                        );
                                    }
                                }
                            }
                        }
                        
                        // Reset drops when they're far enough down screen
                        if (y > this.canvas.height * 1.5) {
                            // Respawn at different times
                            if (Math.random() > 0.99) {
                                this.drops[i] = -Math.floor(Math.random() * 20); // Start above the screen
                                this.speeds[i] = 0.1 + Math.random() * 0.3; // Assign a new speed
                                this.highlights[i] = Math.random() < 0.1; // Recalculate highlight status
                            }
                        }
                        
                        // Occasionally change the speed slightly for natural movement
                        if (Math.random() < 0.002) {
                            this.speeds[i] = Math.max(0.05, Math.min(0.5, this.speeds[i] + (Math.random() - 0.5) * 0.1));
                        }
                    }
                    
                    // Occasionally add a new drop
                    if (Math.random() < 0.05 && this.drops.length < this.columns) {
                        const i = Math.floor(Math.random() * this.columns);
                        if (!this.drops[i] || this.drops[i] * this.fontSize > this.canvas.height) {
                            this.drops[i] = -1;
                            this.speeds[i] = 0.1 + Math.random() * 0.3;
                            this.highlights[i] = Math.random() < 0.1;
                        }
                    }
                }
                
                // Always request next animation frame to keep the loop running
                requestAnimationFrame(() => this.draw());
            }
        }
        
        // Initialize code rain
        const codeRain = new CodeRain();
        
        // History management functions
        function addToHistory(name) {
            const historyList = document.getElementById('historyList');
            const item = document.createElement('li');
            item.classList.add('history-item');
            
            // Create timestamp
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
            
            // Create main content with cyberpunk styling
            item.innerHTML = `
                <span>// ${name}</span>
                <span class="timestamp">${timeString}</span>
            `;
            
            // Add to the beginning of the list
            historyList.insertBefore(item, historyList.firstChild);
            
            // Save to localStorage
            saveHistoryToStorage();
        }
        
        function clearHistory() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            
            // Clear from localStorage
            localStorage.removeItem('wheelHistory');
        }
        
        function saveHistoryToStorage() {
            const historyList = document.getElementById('historyList');
            const historyItems = Array.from(historyList.children).map(item => {
                return {
                    name: item.querySelector('span:first-child').textContent.substring(3), // Remove the "// " prefix
                    time: item.querySelector('.timestamp').textContent
                };
            });
            
            localStorage.setItem('wheelHistory', JSON.stringify(historyItems));
        }
        
        function loadHistoryFromStorage() {
            const historyList = document.getElementById('historyList');
            const savedHistory = localStorage.getItem('wheelHistory');
            
            if (savedHistory) {
                const historyItems = JSON.parse(savedHistory);
                
                historyItems.forEach(item => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('history-item');
                    listItem.innerHTML = `
                        <span>// ${item.name}</span>
                        <span class="timestamp">${item.time}</span>
                    `;
                    historyList.appendChild(listItem);
                });
            }
        }
        
        // Clear history button event
        document.getElementById('clearHistory').addEventListener('click', () => {
            clearHistory();
            // Clear selected names and re-enable spin button
            selectedNames.clear();
            updateSpinButtonState();
        });
        
        // Load history on page load and update selectedNames set
        window.onload = function() {
            loadHistoryFromStorage();
            
            // Initialize selectedNames from existing history
            const historyList = document.getElementById('historyList');
            if (historyList.children.length > 0) {
                Array.from(historyList.children).forEach(item => {
                    const name = item.querySelector('span:first-child').textContent.substring(3); // Remove "// " prefix
                    selectedNames.add(name);
                    console.log(`Added from history: ${name}`);
                });
            }
            
            console.log(`Loaded ${selectedNames.size}/${names.length} names from history`);
            // Update button state based on loaded history
            updateSpinButtonState();
        };

        // Function to check if all names have been selected and update button state
        function updateSpinButtonState() {
            const spinButton = document.getElementById('spinButton');
            
            // Check if all names have been selected
            if (selectedNames.size >= names.length) {
                console.log("All names selected, disabling button");
                spinButton.disabled = true;
                spinButton.title = "All names have been selected. Clear history to spin again.";
            } else {
                console.log(`${selectedNames.size}/${names.length} names selected, button enabled`);
                spinButton.disabled = false;
                spinButton.title = "Spin the wheel to select a random name";
            }
        }
    </script>
</body> // Version management system
</html> const versionManager = {
            // Set this timestamp whenever you update the file
            lastModified: '2023-06-27T12:00:00',
            
            // Initialize the version system
            init() {
                // Check if we have stored version data
                const storedData = localStorage.getItem('wheelVersionData');
                let versionData;
                
                if (storedData) {
                    versionData = JSON.parse(storedData);
                    
                    // If there's a new modification, increment version
                    if (versionData.lastModified !== this.lastModified) {
                        console.log('New version detected');
                        this.incrementVersion(versionData.version);
                        versionData = {
                            version: this.currentVersion,
                            lastModified: this.lastModified
                        };
                        localStorage.setItem('wheelVersionData', JSON.stringify(versionData));
                    }
                } else {
                    // First run, initialize with base version
                    this.currentVersion = "3.1.0";
                    versionData = {
                        version: this.currentVersion,
                        lastModified: this.lastModified
                    };
                    localStorage.setItem('wheelVersionData', JSON.stringify(versionData));
                }
                
                // Display the current version
                this.currentVersion = versionData.version;
                this.updateVersionDisplay();
            },
            
            // Increment the version number according to semantic versioning
            incrementVersion(currentVersion) {
                const parts = currentVersion.split('.');
                let major = parseInt(parts[0], 10);
                let minor = parseInt(parts[1], 10);
                let patch = parseInt(parts[2], 10);
                
                // Increment patch version
                patch++;
                
                // If patch reaches 10, increment minor and reset patch
                if (patch > 9) {
                    minor++;
                    patch = 0;
                    
                    // If minor reaches 10, increment major and reset minor
                    if (minor > 9) {
                        major++;
                        minor = 0;
                    }
                }
                
                this.currentVersion = `${major}.${minor}.${patch}`;
                return this.currentVersion;
            },
            
            // Update the version display in the UI
            updateVersionDisplay() {
                const versionElement = document.querySelector('.version');
                if (versionElement) {
                    versionElement.textContent = `v${this.currentVersion}`;
                }
            }
        };
        
        // Initialize version tracking after the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            versionManager.init();
        });
    </script>
</body>
</html>